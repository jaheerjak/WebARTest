<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Unity WebGL Player | KnokDown WebAR</title>
  <link rel="shortcut icon" href="TemplateData/favicon.ico">
  <link rel="stylesheet" href="TemplateData/style.css">
  <script src="js/lib/aframe.min.js"></script>
    <script src="js/lib/aframe-ar.js"></script>
    <script src="Build/Build.loader.js"></script>

</head>

<body>
    <a-scene embedded arjs vr-mode-ui="enabled: false" copycanvas>

  <div id="unity-container" style="z-index: 5">
	<canvas id="unity-canvas" class="custom-border" data-pixel-art="false"></canvas>
	<div id="unity-loader-container">
	  <div class="loader-icon"></div>
	  <div id="loader-text">0%</div>
	</div>
	<div id="unity-warning" class="custom-border"></div>
	<div id="unity-footer" class="custom-border" hide-footer="false">
	  <div id="unity-fullscreen-button" title="Toggle Fullscreen"></div>
	  <div id="unity-theme-button" title="Toggle Theme"></div>
	  <div id="unity-quit-button" title="Exit"></div>
	</div>
  </div>
  <a-entity camera cameratransform></a-entity>
    </a-scene>
  <script>
    var container = document.querySelector("#unity-container");
    var canvas = document.querySelector("#unity-canvas");
    var loaderContainer = document.querySelector("#unity-loader-container");
	var loaderText = document.querySelector("#loader-text");
    var warningBanner = document.querySelector("#unity-warning");
    var themeButton = document.querySelector("#unity-theme-button");
    var quitButton = document.querySelector("#unity-quit-button");
    var fullscreenButton = document.querySelector("#unity-fullscreen-button");
	var footer = document.querySelector("#unity-footer");
		   
    // Shows a temporary message banner/ribbon for a few seconds, or
    // a permanent error message on top of the canvas if type=='error'.
    // If type=='warning', a yellow highlight color is used.
    // Modify or remove this function to customize the visually presented
    // way that non-critical warnings and error messages are presented to the
    // user.
    function unityShowBanner(msg, type)
    {
      function updateBannerVisibility()
      {
        warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
      }
      var div = document.createElement('div');
      div.innerHTML = msg;
      warningBanner.appendChild(div);
      if (type == 'error') div.style = 'background: red; padding: 10px;';
      else
      {
        if (type == 'warning') div.style = 'background: yellow; padding: 10px;';
        setTimeout(function ()
        {
          warningBanner.removeChild(div);
          updateBannerVisibility();
        }, 5000);
      }
      updateBannerVisibility();
    }

    var buildUrl = "Build";
    var loaderUrl = buildUrl + "/Build.loader.js";
    var config = 
    {
      dataUrl: buildUrl + "/Build.data",
      frameworkUrl: buildUrl + "/Build.framework.js",
        codeUrl: buildUrl + "/Build.wasm",
    streamingAssetsUrl: "StreamingAssets",
    companyName: "DefaultCompany",
    productName: "KnokDown WebAR",
    productVersion: "0.1",
    showBanner: unityShowBanner,
    };



      canvas.style.width = "800px";
      canvas.style.height = "480px";
    

	// Remove styles based on the state of another element directly to maintain position
	if (footer.getAttribute("hide-footer") === "false") {
        loaderContainer.style.transform = "translate(0%, -50%)";
      } else {
        loaderContainer.style.transform = "";
      }
	  

    function toggleTheme()
    {
      const bodyElement = document.querySelector('body');
      const currentTheme = bodyElement.classList.value;

      if (currentTheme === 'dark-theme')
      {
        bodyElement.classList.remove('dark-theme');
        bodyElement.classList.add('light-theme');
      } 
      else
      {
        bodyElement.classList.remove('light-theme');
        bodyElement.classList.add('dark-theme');
      }
    }
    var script = document.createElement("script");
    script.src = loaderUrl; 
	let unityInstance=null;

    script.onload = () => 
	{     
	 createUnityInstance(canvas, config, (progress) => 
	  {
		loaderText.innerText = (100 * progress).toFixed(0) + "%";
	  }).then((Instance) =>
      {
	    unityInstance=Instance;
        loaderContainer.style.display = "none";
        fullscreenButton.onclick = () =>
        {
          unityInstance.SetFullscreen(1);
        };
        themeButton.onclick = () =>
        {
          toggleTheme();
        };
        quitButton.onclick = () =>
        {
          unityInstance.Quit().then(function() {
          unityInstance = null;
        });
        };
      }).catch((message) =>
      {
        unityShowBanner(message, 'error');
        alert(message);
      });
    };
	let isCameraReady = false;
	let isDetectionManagerReady = false;
	let gl = null;

	function cameraReady(){
		isCameraReady = true;
		console.log("camera ready");
		gl = unityInstance.Module.ctx;
	}
	function detectionManagerReady(){
    isDetectionManagerReady = true;
	}
	
	function createUnityMatrix(el){
		const m = el.matrix.clone();
		const zFlipped = new THREE.Matrix4().makeScale(1, 1, -1).multiply(m);
		const rotated = zFlipped.multiply(new THREE.Matrix4().makeRotationX(-Math.PI/2));
		return rotated;
	}

	AFRAME.registerComponent('markercontroller', {
    schema: {
        name : {type: 'string'}
    },
    tock: function(time, timeDelta){

        let position = new THREE.Vector3();
        let rotation = new THREE.Quaternion();
        let scale = new THREE.Vector3();

        createUnityMatrix(this.el.object3D).decompose(position, rotation, scale);

        const serializedInfos = `${this.data.name},${this.el.object3D.visible},${position.toArray()},${rotation.toArray()},${scale.toArray()}`;

        if(isDetectionManagerReady){
          unityInstance.SendMessage("DetectionManager", "markerInfos", serializedInfos);
        }
    } 
	});

	AFRAME.registerComponent('cameratransform', {
    tock: function(time, timeDelta){

        let camtr = new THREE.Vector3();
        let camro = new THREE.Quaternion();
        let camsc = new THREE.Vector3();

        this.el.object3D.matrix.clone().decompose(camtr, camro, camsc);

        const projection = this.el.components.camera.camera.projectionMatrix.clone();
        const serializedProj = `${[...projection.elements]}`

        const posCam = `${[...camtr.toArray()]}`
        const rotCam = `${[...camro.toArray()]}`
 
        if(isCameraReady){
            unityInstance.SendMessage("Main Camera", "setProjection", serializedProj);
            unityInstance.SendMessage("Main Camera", "setPosition", posCam);
            unityInstance.SendMessage("Main Camera", "setRotation", rotCam);

            let w = window.innerWidth;
            let h = window.innerHeight; 

            const unityCanvas = document.getElementsByTagName('canvas')[0];

            const ratio = unityCanvas.height / h;

            w *= ratio
            h *= ratio

            const size = `${w},${h}`
			console.log("camera ready");
            unityInstance.SendMessage("Canvas", "setSize", size);
        }

        if(gl != null){
            gl.dontClearOnFrameStart = true;
        }
    } 
	});

	AFRAME.registerComponent('copycanvas', {
    tick: function(time, timeDelta){
        const unityCanvas = document.getElementsByTagName('canvas')[0];
        unityCanvas.width = this.el.canvas.width
        unityCanvas.height = this.el.canvas.height
    } 
	});
    document.body.appendChild(script);
  </script>
</body>
</html>
